package main

import (
	"bytes"
	"flag"
	"fmt"
	"golang.org/x/crypto/ssh"
	"net"
)

var (
	username = flag.String("username", "root", "username")
	serverIP = flag.String("ip", "127.0.0.1", "IP")
	sshPort  = flag.String("port", "22", "port")
)

func main() {
	flag.Parse()
	//privateBytes, err := os.ReadFile("~/.ssh/id_rsa")
	//if err != nil {
	//	panic(err)
	//}
	//private, err := ssh.ParsePrivateKey(privateBytes)
	//if err != nil {
	//	panic(err)
	//}
	//var hostKey ssh.PublicKey
	cfg := &ssh.ClientConfig{
		User:            *username,
		Auth:            []ssh.AuthMethod{ssh.Password("123456")},
		HostKeyCallback: func(hostname string, remote net.Addr, key ssh.PublicKey) error {
			return nil
		},
	}
	client, err := ssh.Dial("tcp", fmt.Sprintf("%s:%s", *serverIP, *sshPort), cfg)
	if err != nil {
		panic(err)
	}
	defer client.Close()

	session, err := client.NewSession()
	if err != nil {
		panic(err)
	}
	defer session.Close()

	var b bytes.Buffer
	session.Stdout = &b
	if err := session.Run("/usr/bin/whoami"); err != nil {
		panic(err)
	}
	fmt.Println(b.String())

	// Set up terminal modes
	modes := ssh.TerminalModes{
		ssh.ECHO:          0,     // disable echoing
		ssh.TTY_OP_ISPEED: 14400, // input speed = 14.4kbaud
		ssh.TTY_OP_OSPEED: 14400, // output speed = 14.4kbaud
	}
	// Request pseudo terminal
	if err := session.RequestPty("xterm", 40, 80, modes); err != nil {
		panic(err)
	}
	// Start remote shell
	if err := session.Shell(); err != nil {
		panic(err)
	}

	//fmt.Println(client.Conn.RemoteAddr())
	//fmt.Println(client.Conn.LocalAddr())
	//ch, req, err := client.OpenChannel("ch1", nil)
	//if err != nil {
	//	fmt.Println(ch)
	//	panic(err)
	//}
	//d := <-req
	//fmt.Println(d.Type)

	// 请求pty：标准输出终端
	//ok, err := ch.SendRequest("pty-req", true, ssh.Marshal(ssh.Request{
	//
	//}))

}
